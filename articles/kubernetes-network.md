# Kubernetes 网络模型 
每一个 Pod 都有它自己的IP地址， 这就意味着你不需要显式地在 Pod 之间创建链接， 你几乎不需要处理容器端口到主机端口之间的映射。 这将形成一个干净的、向后兼容的模型；在这个模型里，从端口分配、命名、服务发现、 负载均衡、应用配置和迁移的角度来看， Pod 可以被视作虚拟机或者物理主机。

Kubernetes 强制要求所有网络设施都满足以下基本要求（从而排除了有意隔离网络的策略）：

* 节点上的 Pod 可以不通过 NAT 和其他任何节点上的 Pod 通信
* 节点上的代理（比如：系统守护进程、kubelet）可以和节点上的所有 Pod 通信 

Kubernetes 的 IP 地址存在于 Pod 范围内 - 容器共享它们的网络命名空间 - 包括它们的 IP 地址和 MAC 地址。 这就意味着 Pod 内的容器都可以通过 localhost 到达对方端口。 这也意味着 Pod 内的容器需要相互协调端口的使用，但是这和虚拟机中的进程似乎没有什么不同， 这也被称为“一个 Pod 一个 IP”模型。

也可以在 Node 本身请求端口，并用这类端口转发到你的 Pod（称之为主机端口）， 但这是一个很特殊的操作。转发方式如何实现也是容器运行时的细节。 Pod 自己并不知道这些主机端口的存在。

Kubernetes 网络解决四方面的问题：

* 一个 Pod 中的容器之间通过本地回路（loopback）通信。
* 集群网络在不同 pod 之间提供通信。
* Service 资源允许你 对外暴露 Pods 中运行的应用程序， 以支持来自于集群外部的访问。
* 可以使用 Services 来发布仅供集群内部使用的服务。


## POD 内网络通信

> 一个pod由一个或多个容器组成，它们位于同一主机上，并被配置为共享网络空间和其他资源，如文件卷(volumes)。

这意味着一个pod中的所有容器都可以在localhost，比如一个容器内部署80端口的nginx应用可以代理转发另一个容器内的3000端口应用，见: [理解pod内网络](https://juejin.cn/post/7037835146162077704)

## 不同 pod 之间的通信

不同pod之间可以通过访问对应的集群内IP地址进行通信，可以通过 `kubectl describe pod [pod-name]` 或者 `kubectl get pods -o wide` 获取pod的对应集群内地址，在集群内任意一个pod中直接访问该IP和对应端口号即可与指定pod通信。

但是我们没有办法在任何一个部署环境中这么使用，因为每个pod内的服务无法知道其他服务的pod ip，所以需要有一种机制将所有的pod ip管理起来，按照服务来对这些IP进行分类。这就是服务发现了。

我们可以选择一个注册中心，每个服务启动时向该中心进行注册，关闭时从该服务删除本pod，这样就可以从注册中心中拿到每个服务下可用的pod ip了。这是一般的第三方注册中心实现方式，需要侵入我们的应用代码实现，但k8s提供了一种无侵入的服务发现方式，即service。

k8s 的 service 是一种基于 dns 模式的服务发现方式，注册一个service实际上是生成了以该 service name 命名的‘域名’，各pod向此‘域名’发出请求时，k8s会解析该‘域名’并返回一个可用的pod ip。

### service 是如何知道本服务下有哪些pod可用的



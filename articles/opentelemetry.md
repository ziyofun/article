## OpenTelemetry是什么？

OpenTelemetry 是一组标准和工具的集合，旨在管理遥测数据，如 trace、metrics、logs 等 (未来可能有新的遥测数据类型出现)。OpenTelemetry 提供与厂商无关的实现，根据用户的需要将遥测数据导出到不同的后端，如开源的 Prometheus、Jaeger 或云厂商的服务中。

## 为什么需要使用 OpenTelemetry 以及它能做什么？

在现代云原生技术栈中，分布式和多语种架构很常见。分布式架构带来一系列挑战，包括如何快速解决可用性或性能问题，这些挑战最后都指向了如何提升服务的可观测性这一问题。想要提升服务的可观测性，遥测数据必不可少。传统的遥测数据往往由开源或者商业项目提供，但由于缺乏标准，最终会导致缺乏可移植性并且加重用户的运维成本。

OpenTelemetry 通过提供一个统一的、与厂商无关的方案来解决这些问题，并且该项目已得到了云厂商、供应商和最终用户的广泛行业支持和采用。

OpenTelemetry 提供了: 
    1. 为每种语言提供了一个与供应商无关的配置库
    2. 一个 collector 应用，支持多种部署模式包括但不限于agent或gateway
    3. 一个包括了从生产、收集、处理到导出遥测数据的端到端的实现
    4. 通过配置文件可以管理遥测数据并并行发送至多个backend
    5. 开放标准语义约定，以确保与供应商无关的数据收集
    6. 能够并行支持多种上下文传播格式，以帮助随着标准的发展进行迁移
    7. 一个方便使用和从现有厂商实现（包括 OpenTracing 和 OpenCensus）向 OpenTelemetry 迁移的方式

## OpenTelemetry 不是什么？

OpenTelemetry 不是像 Jaeger 或 Prometheus 那样的可观测性的后端服务。但它支持向这些后端服务导出数据。

（个人理解）总的来说，OpenTelemetry 规范了遥测数据应该如何产出、收集、处理导出等规范，但不具体规定遥测数据必须是什么格式或以什么方式存储，相当于提供了一套遥测数据的接口，社区可以按照这些接口来实现各种SDK、插件等。


# 数据源

OpenTelemetry 目前支持以下三种遥测数据，未来可能会支持更多类型。

## Traces

Traces 数据用来跟踪单个请求的进度，一条请求生成的 Traces 数据称为一个 trace，一般由应用中的多个服务来处理。请求可以由用户或应用发起，分布式跟踪是一种跨越进程、网络和安全边界的跟踪形式。一个trace中的最小单元称为一个 span。一个 trace 能够表现为多个 span 组成的树状结构，span 表示一个请求流经某一特定服务时的各种数据。每个 span 都会包含一个上下文，该上下文一般由全局唯一的标识符来组成用于表示唯一一次请求，而每个 span 都是其中的一部分。span 还提供了一些度量数据用来debug或者进行性能分析。

每一个 trace 都包含一个根 span，它包含了该请求的总消耗时间等信息。您可以将其视为单个逻辑操作，例如单击 Web 应用程序中的按钮以将产品添加到购物车。根 span 将测量从最终用户单击该按钮到操作完成或失败（将项目添加到购物车或发生某些错误）以及显示给用户的结果所花费的时间。一个 trace 由单个根 span 和任意数量的子 span 组成，它们共同表示一个完整请求。每个跨度都包含有关操作的元数据，例如其名称、开始和结束时间戳、属性、事件和状态。

OpenTelemetry 提供了 tracer 接口用来创建和管理 span，在进程中一般需要借助它追踪当前活跃span，或者为当前 span 添加属性、事件或者在其结束时关闭它。通过 tracer 的提供者可以创建一到多个 tracer。

一般来说，一个 span 的生命周期可以表示如下:

*. 当一个服务接受到一个请求时，会并从请求头中（如果存在）解析出创建一个 span 所需的上下文信息
*. 使用解析出的上下文信息创建一个新的 span ，如果不存在上下文信息，则创建一个根 span
*. 服务处理请求。可能会附加一些属性和事件信息添加到 span 上，这有助于理解请求上下文的含义，例如处理请求的机器的主机名或客户标识符。
*. 当服务中包含子组件时，可以为每个子组件创建新的span（子组件完成工作时需要关闭对应span）
*. 当目前的服务需要请求其他服务时，需要将当前的span上下文序列化并注入到请求头或其他元数据中去，方便下游服务以对应的方式解析。
*. 当目前的服务完成了处理工作（不管成功与否），需要为当前 span 设定合适的状态，而该 span 会被标记为完成。

## Metrics

一个 metric 表示某个服务在程序运行时捕获的一次度量数据。捕获度量数据的时刻叫做 metric event，它不仅包含了度量数据本身，同时也包含了捕获的时间以及其他相关的元数据。

程序和请求度量对于可用性和性能来说是很重要的指标，自定义指标可以深入了解可用性指标如何影响用户体验或业务。收集到的数据可用于触发警报或调度决策，以便在高需求时自动扩展部署。

OpenTelemetry 目前定义了的三种度量工具：

*. counter: 随时间递增的数据，类比于汽车的里程表，只会增加
*. measure: 随时间变化的平均值，表示一段范围内的值
*. observer: 在特定时间点捕获的一组当前值。

除了三个度量工具之外，聚合也是一个需要理解的重要概念。一个聚合是将某个时间窗口内的大量度量数据组合而成统计数据。OpenTelemetry API 本身不允许用户指定这些聚合，但提供了一些默认聚合。通常情况下，OpenTelemetry SDK 会提供一些可视化工具和遥测 backend 常见的聚合数据（例如 sum、count、last value 和 histograms）。

与旨在捕获请求生命周期并为请求的各个部分提供上下文的请求 trace 不同，metric 旨在提供汇总的统计信息。metric 的常见用例包括：

*. 上报服务每种协议类型读取的字节总数
*. 上报服务读取的总字节数和每个请求的字节数
*. 上报一次系统调用的时长
*. 上报请求大小以确定服务负载趋势
*. 上报CPU和内存使用情况
*. 上报被处理的当前活跃请求数量

## Logs

一条 log 信息是包含元数据和时间戳的结构或非结构化的文本信息。虽然 log 是一个独立的数据源，但它们也可以附加到 span。在 OpenTelemetry 中，任何不属于分布式 trace 或 metric 的数据都是 log。日志经常被用来直观地确定各种问题以及记录各种数据操作。


## Baggage

除了 trace，OpenTelemetry 还提供了一种简单的机制来传播键/值对，被称为 Baggage。Baggage 设计的目的是用于在相同事务中检索出想要的可观测性事件。虽然 Baggage 可用于其他用途，但该机制主要旨在传达 OpenTelemetry 可观察性系统的价值。

这些 Baggage 中的键/值对可以被 metrics、logs 或 traces作为额外数据消费，有以下使用场景：

*. 什么服务发送了本次请求（app-from）
*. 本次请求用户的ID或token
*. 本次请求的浏览器版本

# OpenTelemetry 的使用（仅trace）

## 数据生产

OpenTelemetry 提供了各种各样的SDK或依赖以满足各种语言/框架下的遥测数据生产和管理需求。想要生产一条 span 依照上述 span 生命周期需要有以下几个步骤：

1. 依赖的引入：OpenTelemetry为大多数的主流语言及框架都提供了自动配置的库，这些库可以通过一些中间件、hook或者monkey-patch等方式来进行span的自动生成。对于未提供的冷门语言或框架可以选择依赖于API自己实现一个库，但对于我们来说应该没有这个必要。
2. 库的配置：引入了 OpenTelemetry 的库后需要进行一些简单配置，比如当前服务名称、版本号，一些默认的attribute或者collector的地址等。
3. span的生成：从请求头/元数据中解析出对应上下文，并作为parent span，并生成一个当前服务的child span。
4. span的传递：需要将当前活跃的span上下文注入到请求下游服务的请求头或元数据中去。
5. span的操作和关闭：可以为span设置各种attribute或者status，在当前请求结束时（无论成功还是报错）将当前span关闭

## 数据收集

在 OpenTelemetry 中可以将数据从程序中直接发送给backend，但是不推荐这样做，为了方便对遥测数据的管理和拓展，官方推荐的方法是使用 OpenTelemetry Collector，OpenTelemetry Collector 提供了一套收集处理遥测数据的标准方式，它与厂商无关可以兼容现有的大多数主流遥测数据格式并可以发送给各种各样的backend，并且具有良好的拓展性。OpenTelemetry Collector 的使用方式类似于一些CI/CD工具，它基于配置，并可以依据配置内容形成一个或多个pipeline来对遥测数据进行收集、加工和发送。

OpenTelemetry Collector提供了一个程序和两种部署模式：

* Agent：为每个应用程序都部署一个OpenTelemetry Collector实例，具体来说可以分为跟随应用启动、sidecar或者daemonset。
* Gateway：为所有程序部署一组OpenTelemetry Collector实例并负载均衡，比如deployment。

OpenTelemetry Collector的工作模式是pipelines，而组成pipeline的组件有以下三种：

* receivers：数据的接收器，作为pipelines的入口，每一种不同格式或者不同协议的遥测数据都需要有其对应的 receivers 才能被收集
* processors：数据的处理器，可以定义如何处理遥测数据，常见的有打印、批处理、失败重试等
* exporters：数据发送器，将数据发送至各种backend需要有对应的 exporters，一般云服务商会为自己的 backend 提供对应的exporters

OpenTelemetry Collector有两种不同的版本：

* Core版：提供了对常见流行的几种开源项目的支持，比如 Jaeger、Prometheus等
* Contrib版：提供了包含Core版在内的所有功能，并包含了一些实验组件和一些特定服务商的定制receivers、procesors、exporters等。